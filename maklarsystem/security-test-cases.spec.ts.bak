import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { NextRequest, NextResponse } from 'next/server';
import { 
  createRateLimiter, 
  strictSanitizer,
  moderateSanitizer,
  CSRFProtection,
  SecurityHeaders,
  compressionMiddleware
} from '@/lib/security';
import { ResponseCache, QueryCache } from '@/lib/performance';

describe('Security Features Test Suite', () => {
  
  describe('Rate Limiting', () => {
    let rateLimiter: any;
    
    beforeEach(() => {
      rateLimiter = createRateLimiter({
        windowMs: 1000, // 1 second
        maxRequests: 2, // 2 requests per second
      });
    });

    it('should allow requests within limit', async () => {
      const req = new NextRequest('http://localhost:3000/api/test');
      
      const isLimited1 = await rateLimiter.isRateLimited(req);
      const isLimited2 = await rateLimiter.isRateLimited(req);
      
      expect(isLimited1).toBe(false);
      expect(isLimited2).toBe(false);
    });

    it('should block requests exceeding limit', async () => {
      const req = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimiter.isRateLimited(req);
      await rateLimiter.isRateLimited(req);
      const isLimited = await rateLimiter.isRateLimited(req);
      
      expect(isLimited).toBe(true);
    });

    it('should reset after window expires', async () => {
      const req = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimiter.isRateLimited(req);
      await rateLimiter.isRateLimited(req);
      
      // Wait for window to expire
      await new Promise(resolve => setTimeout(resolve, 1100));
      
      const isLimited = await rateLimiter.isRateLimited(req);
      expect(isLimited).toBe(false);
    });

    it('should return correct rate limit headers', async () => {
      const req = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimiter.isRateLimited(req);
      
      const remaining = rateLimiter.getRemainingRequests(req);
      const retryAfter = rateLimiter.getRetryAfter(req);
      
      expect(remaining).toBe(1);
      expect(retryAfter).toBeGreaterThanOrEqual(0);
      expect(retryAfter).toBeLessThanOrEqual(1);
    });
  });

  describe('Input Sanitization', () => {
    it('should remove dangerous HTML tags', () => {
      const input = '<script>alert("XSS")</script><p>Safe text</p>';
      const result = strictSanitizer.sanitize(input);
      
      expect(result.clean).toBe('<p>Safe text</p>');
      expect(result.removed).toContain('<script>');
      expect(result.sanitized).toBe(true);
    });

    it('should preserve Swedish characters', () => {
      const input = 'Hej från Östergötland, åäöÅÄÖ';
      const result = moderateSanitizer.sanitize(input);
      
      expect(result.clean).toBe(input);
      expect(result.sanitized).toBe(false);
    });

    it('should sanitize object properties', () => {
      const obj = {
        name: '<b>Test</b>',
        description: '<script>bad</script>Good text',
        nested: {
          value: '<img src=x onerror=alert(1)>',
        },
      };
      
      const sanitized = moderateSanitizer.sanitizeObject(obj);
      
      expect(sanitized.name).toBe('<b>Test</b>');
      expect(sanitized.description).toBe('Good text');
      expect(sanitized.nested.value).toBe('<img src="x">');
    });

    it('should handle different sanitization profiles', () => {
      const input = '<a href="http://example.com" onclick="alert(1)">Link</a>';
      
      const strict = strictSanitizer.sanitize(input);
      const moderate = moderateSanitizer.sanitize(input);
      
      expect(strict.clean).toBe('Link'); // Removes all tags
      expect(moderate.clean).toBe('<a href="http://example.com">Link</a>'); // Keeps safe attributes
    });
  });

  describe('CSRF Protection', () => {
    let csrf: CSRFProtection;
    
    beforeEach(() => {
      csrf = new CSRFProtection({ doubleSubmit: true });
    });

    it('should generate unique tokens', () => {
      const token1 = csrf.generateToken();
      const token2 = csrf.generateToken();
      
      expect(token1).toBeDefined();
      expect(token2).toBeDefined();
      expect(token1).not.toBe(token2);
      expect(token1.length).toBe(64); // 32 bytes = 64 hex chars
    });

    it('should validate matching tokens', async () => {
      const token = csrf.generateToken();
      
      // Create request with token in header and cookie
      const req = new NextRequest('http://localhost:3000/api/test', {
        method: 'POST',
        headers: {
          'x-csrf-token': token,
        },
      });
      
      // Mock cookie
      Object.defineProperty(req.cookies, 'get', {
        value: jest.fn().mockReturnValue({ value: token }),
      });
      
      const isValid = await csrf.validateToken(req);
      expect(isValid).toBe(true);
    });

    it('should reject mismatched tokens', async () => {
      const req = new NextRequest('http://localhost:3000/api/test', {
        method: 'POST',
        headers: {
          'x-csrf-token': 'wrong-token',
        },
      });
      
      Object.defineProperty(req.cookies, 'get', {
        value: jest.fn().mockReturnValue({ value: 'different-token' }),
      });
      
      const isValid = await csrf.validateToken(req);
      expect(isValid).toBe(false);
    });

    it('should skip validation for safe methods', async () => {
      const req = new NextRequest('http://localhost:3000/api/test', {
        method: 'GET',
      });
      
      const handler = jest.fn().mockResolvedValue(new NextResponse());
      const response = await csrf.protect(req, handler);
      
      expect(handler).toHaveBeenCalled();
    });
  });

  describe('Security Headers', () => {
    let headers: SecurityHeaders;
    
    beforeEach(() => {
      headers = new SecurityHeaders();
    });

    it('should add all security headers', () => {
      const response = new NextResponse();
      headers.applyHeaders(response);
      
      expect(response.headers.get('X-Frame-Options')).toBe('DENY');
      expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
      expect(response.headers.get('X-XSS-Protection')).toBe('1; mode=block');
      expect(response.headers.get('Referrer-Policy')).toBe('strict-origin-when-cross-origin');
      expect(response.headers.get('Content-Security-Policy')).toBeDefined();
      expect(response.headers.get('Strict-Transport-Security')).toBeDefined();
    });

    it('should respect configuration options', () => {
      const customHeaders = new SecurityHeaders({
        xFrameOptions: 'SAMEORIGIN',
        xXssProtection: false,
      });
      
      const response = new NextResponse();
      customHeaders.applyHeaders(response);
      
      expect(response.headers.get('X-Frame-Options')).toBe('SAMEORIGIN');
      expect(response.headers.get('X-XSS-Protection')).toBeNull();
    });
  });

  describe('Response Caching', () => {
    let cache: ResponseCache;
    
    beforeEach(() => {
      cache = new ResponseCache({
        maxAge: 1000, // 1 second
        staleWhileRevalidate: 500, // 0.5 seconds
      });
    });

    it('should cache successful responses', async () => {
      const req = new NextRequest('http://localhost:3000/api/test');
      const data = { message: 'test' };
      const res = NextResponse.json(data);
      
      await cache.set(req, res);
      const cached = await cache.get(req);
      
      expect(cached).toBeDefined();
      expect(cached?.data).toEqual(data);
      expect(cached?.headers['x-cache-status']).toBe('hit');
    });

    it('should serve stale content during revalidation window', async () => {
      const req = new NextRequest('http://localhost:3000/api/test');
      const res = NextResponse.json({ test: true });
      
      await cache.set(req, res);
      
      // Wait for content to become stale but within revalidation window
      await new Promise(resolve => setTimeout(resolve, 1100));
      
      const cached = await cache.get(req);
      expect(cached).toBeDefined();
      expect(cached?.headers['x-cache-status']).toBe('stale');
    });

    it('should handle conditional requests with ETags', async () => {
      const data = { message: 'test' };
      const req = new NextRequest('http://localhost:3000/api/test');
      const res = NextResponse.json(data);
      
      await cache.set(req, res);
      const cached = await cache.get(req);
      
      // Create request with If-None-Match
      const conditionalReq = new NextRequest('http://localhost:3000/api/test', {
        headers: {
          'if-none-match': cached?.etag || '',
        },
      });
      
      const handler = jest.fn();
      const response = await cache.withCache(conditionalReq, handler);
      
      expect(response.status).toBe(304);
      expect(handler).not.toHaveBeenCalled();
    });
  });

  describe('Query Caching', () => {
    let queryCache: QueryCache;
    
    beforeEach(() => {
      queryCache = new QueryCache({ ttl: 1000 });
    });

    it('should cache query results', async () => {
      const fetcher = jest.fn().mockResolvedValue({ data: 'test' });
      
      const result1 = await queryCache.get('test-key', fetcher);
      const result2 = await queryCache.get('test-key', fetcher);
      
      expect(result1).toEqual({ data: 'test' });
      expect(result2).toEqual({ data: 'test' });
      expect(fetcher).toHaveBeenCalledTimes(1);
    });

    it('should invalidate cache by pattern', async () => {
      const fetcher1 = jest.fn().mockResolvedValue({ data: 'user1' });
      const fetcher2 = jest.fn().mockResolvedValue({ data: 'user2' });
      
      await queryCache.get('user:1', fetcher1);
      await queryCache.get('user:2', fetcher2);
      
      queryCache.invalidatePattern('user:');
      
      await queryCache.get('user:1', fetcher1);
      await queryCache.get('user:2', fetcher2);
      
      expect(fetcher1).toHaveBeenCalledTimes(2);
      expect(fetcher2).toHaveBeenCalledTimes(2);
    });
  });

  describe('Compression', () => {
    it('should compress large responses', async () => {
      const largeData = 'x'.repeat(2000); // 2KB of data
      const req = new NextRequest('http://localhost:3000/api/test', {
        headers: {
          'accept-encoding': 'gzip, deflate',
        },
      });
      
      const handler = jest.fn().mockResolvedValue(
        new NextResponse(largeData, {
          headers: {
            'content-type': 'text/plain',
          },
        })
      );
      
      const response = await compressionMiddleware.middleware(req, handler);
      
      expect(response.headers.get('content-encoding')).toBe('gzip');
      expect(response.headers.get('vary')).toBe('Accept-Encoding');
    });

    it('should skip compression for small responses', async () => {
      const smallData = 'small';
      const req = new NextRequest('http://localhost:3000/api/test', {
        headers: {
          'accept-encoding': 'gzip',
        },
      });
      
      const handler = jest.fn().mockResolvedValue(
        new NextResponse(smallData, {
          headers: {
            'content-type': 'text/plain',
            'content-length': smallData.length.toString(),
          },
        })
      );
      
      const response = await compressionMiddleware.middleware(req, handler);
      
      expect(response.headers.get('content-encoding')).toBeNull();
    });
  });
});

// Integration test example
describe('Security Integration', () => {
  it('should handle secure API request flow', async () => {
    // This would test the complete flow:
    // 1. Rate limiting check
    // 2. CSRF validation
    // 3. Input sanitization
    // 4. Request processing
    // 5. Response caching
    // 6. Security headers
    // 7. Compression
    
    // Implementation would require mocking the full middleware chain
  });
});